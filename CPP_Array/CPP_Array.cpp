// CPP_Array.cpp : このファイルには 'main' 関数が含まれています。プログラム実行の開始と終了がそこで行われます。
//

#include <iostream>
#define ESCBLK "\033[30m"
#define ESCRED "\033[31m"
#define ESCGRN "\033[32m"
#define ESCYRW "\033[33m"
#define ESCBLU "\033[34m"
#define ESCMGN "\033[35m"
#define ESCCYN "\033[36m"
#define ESCWHT "\033[37m"
#define ESCDEF "\033[0m"


int main()
{
    //「文字列」の定義
    char ARRAY0[5] = "ABCD"; //4文字までしか入らない。
    std::cout << "ARRAY0: " << ARRAY0 << std::endl;
    //5個分確保しているのに、4文字までしか入らないのはなぜか?

    //配列とポインタのサンプル
    //「文字の配列」として定義
    char ARRAY1[5] = { 'A', 'B', 'C', 'D', 'E' };
    
    // ポインタ変数「ARRAY0」を表示　(void*)はポインタ型にキャストする。メモリ上のアドレスが表示される。
    std::cout << "ARRAY1: " << ARRAY1 << std::endl;//ゴミが出てくる
    /////////////////////////////////////////////////////////////////////////////////////////////////////
    //なぜゴミがつくのか？ポインタ変数は、メモリ上のアドレスを示すだけで、実際の値は示していないからです。
    //「 std::cout << 」は終端文字'\0'が出てくるまで表示し続けるのでゴミが出てきます。
    // '\0'はnullで、よく使われるので、メモリの所々に入っています。

    /////////////////////////////////////////////////////////////////////////////////
    // C/C++のポインタはメモリのどこでも指すことができる
    // ⇒ハッキングができる!!(実際には、OSやCPUで制限されているのでそう簡単ではない)

    //下記のようにするときちんと表示される。
    std::cout << "ARRAY1([0]+[1]+[2]+[3]+[4]): "
        << ARRAY1[0]
        << ARRAY1[1]
        << ARRAY1[2]
        << ARRAY1[3]
        << ARRAY1[4]
        << std::endl << std::endl;

    /////////////////////////////////////////////////////////////////////////////////
    //正しく表示するには終端を指示する必要がある。'\0'が終端文字
    char ARRAY2[6] = { 'A', 'B', 'C', 'D', 'E', '\0'};
    std::cout << "ARRAY2(文字列定義): " << ARRAY2 << std::endl;
    //5文字の文字列を格納するには6個分のメモリが必要

    /////////////////////////////////////////////////////////////////////////////////
    //「文字列」として定義されたARRAI0も、同じ配列なので、下記のように表示可能。
    std::cout << "ARRAY0([0]+[1]+[2]+[3]+[4]): "
        << ARRAY0[0]
        << ARRAY0[1]
        << ARRAY0[2]
        << ARRAY0[3]
        << ARRAY0[4] //ここは終端文字'\0'が入っているので、表示されない。
        << std::endl << std::endl;




    return 0;
}

