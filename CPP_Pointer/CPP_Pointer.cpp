//ポインタと参照の参照のサンプル
#include <conio.h>
#include <iostream>
#include <vector>

#define ESCBLK "\033[30m"
#define ESCRED "\033[31m"
#define ESCGRN "\033[32m"
#define ESCYRW "\033[33m"
#define ESCBLU "\033[34m"
#define ESCMGN "\033[35m"
#define ESCCYN "\033[36m"
#define ESCWHT "\033[37m"
#define ESCDEF "\033[0m"

//ポインタが難しいというより、'&' や '*' の使い方に混乱があるので難しく感じます。
//Cの開発当時、使える記号の数が限られていたので、'&' や '*' が複数の意味を持つようになっています。
//演算子(それも複数の意味)だったり、参照だったり、ポインタだったりします。
//これらの記号は使われる場所によって意味が変わるので、よく注意しましょう。

// '*'
// 左辺にある場合は、「ポインタ変数」を示す「型宣言子」です。
// 右辺にある場合は、「ポインタ変数」が指している「値」を示す「間接参照演算子」です。ポインタを値に変換する演算子と覚えてください。
// 関数の宣言の引数で使われる場合は、「ポインタ変数」を示す「型宣言子」となります。
// 変数の宣言の戻り値に使われる場合も、「ポインタ変数」を示す「型宣言子」となります。
// 式の中で 'x * y' のように使われる場合は、乗算演算子として使われます。

// '&'
// 左辺にある場合は、「参照型変数」を示す「型宣言子」です。
// 右辺にある場合は、「アドレス演算子」です。変数のアドレスを取得する演算子と覚えてください。
// 関数の宣言の引数で使われる場合は、「参照型変数」を示す「型宣言子」となります。
// 変数の宣言の戻り値に使われる場合も、「参照型変数」を示す「型宣言子」となります。
// 式の中で 'x & y' のように使われる場合は、ビットAND演算子として使われます。

//実行のたびにアドレスが変わるのを確認してください。
//パソコンのメモリの空き具合などで毎回同じアドレスにはならないです。

using namespace std;
//見づらかったのでnamespace std;を使うようにしました。
//これでstd::を省略出来ますが、using はあまり使わない方が良いです。

int main()
{
    cout<< "////////////////////////////////////////////\n"
        << "//   整数VALUE_Aの値と、そのアドレス      //\n"
        << "////////////////////////////////////////////\n";
    int VALUE_A = 196809;
    cout << ESCGRN
        <<"VALUE_Aの値       : " << VALUE_A << endl
        << "VALUE_Aのアドレス: " << &VALUE_A << endl
        << ESCDEF;

    cout << endl
        << "///////////////////////////////////////////////////////////////////////////////\n"
        << "//整数VALUE_Aのアドレスを 別の整数に代入                                     //\n"
        << "//ADDRESS_OF_Aの「値」と「VALUE_Aのアドレス」が同じかどうか確認してください。//\n"
        << "///////////////////////////////////////////////////////////////////////////////\n";
    int64_t ADDRESS_OF_A = (int64_t)&VALUE_A; // ポインタ変数pにaのアドレスを代入 64bit環境ではアドレスは64bitなので、int64_tを使う
    cout << ESCGRN
        << "ADDRESS_OF_Aの値(10進数表示): " << dec << ADDRESS_OF_A << endl
        << "ADDRESS_OF_Aの値(16進数表示): " << hex << ADDRESS_OF_A << endl
        << ESCDEF;

    cout<< "【解説】\n"
        << "「 & 」を付けると、ポインタのアドレスが返される。\n"
        << "「 & 」 は 演算子の一つ。アドレス演算子。\n"
        << "「 & 」 の意味は 右辺と左辺で意味が異なるので覚えてください。\n"
        << "右辺に「 & 」がある場合はアドレス演算子。\n"
        << "左辺の「 & 」がある場合は参照型を示す。\n\n";

    cout<< "///////////////////////////////////////////////////////////////////////////////\n"
        << "//整数のADDRESS_OF_Aの差すメモリにある値                                     //\n"
        << "///////////////////////////////////////////////////////////////////////////////\n";
    cout << ESCGRN
        << "ADDRESS_OF_Aの差すメモリにある値: " << dec << *((int*)ADDRESS_OF_A) << endl
        << ESCDEF;
    cout<< "【解説】\n"
        << "ADDRESS_OF_Aの「値」をポインタ型に変換。\n"
        << "さらに、間接参照演算子を使って、ポインタの指す先の値を取得して表示\n\n";

    cout << "///////////////////////////////////////////////////////////////////////////////\n"
        << "//整数のADDRESS_OF_Aの差すメモリの隣にある値" ESCBLU" 何が出るかなドキドキ" ESCDEF"            //\n"
        << "///////////////////////////////////////////////////////////////////////////////\n";
    cout << ESCGRN
        << "ADDRESS_OF_Aの差すメモリの隣にある値: " << dec << *((int*)ADDRESS_OF_A + 1) << endl
        << ESCDEF;
    cout<< "【解説】\n"
        << "ADDRESS_OF_Aの「値」にプラス1してから、ポインタ型に変換。\n"
        << "さらに、間接参照演算子を使って、ポインタの指す先の値を取得して表示\n";


    return 0;

}


